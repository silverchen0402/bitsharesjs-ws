"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.orders=exports.crypto=exports.history=exports.network=exports.db=exports.close=exports.chainId=exports.instance=exports.reset=exports.setAutoReconnect=exports.setRpcConnectionStatusCallback=void 0;var _ChainWebSocket=_interopRequireDefault(require("./ChainWebSocket")),_GrapheneApi=_interopRequireDefault(require("./GrapheneApi")),_ChainConfig=_interopRequireDefault(require("./ChainConfig"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}var autoReconnect=!1,Apis=null,statusCb=null;// by default don't use reconnecting-websocket
const setRpcConnectionStatusCallback=a=>{statusCb=a,Apis&&Apis.setRpcConnectionStatusCallback(a)};exports.setRpcConnectionStatusCallback=setRpcConnectionStatusCallback;const setAutoReconnect=a=>{autoReconnect=a};exports.setAutoReconnect=setAutoReconnect;const reset=(a="ws://localhost:8090",b,c=4e3,d,e)=>close().then(()=>(Apis=newApis(),Apis.setRpcConnectionStatusCallback(statusCb),Apis&&b&&Apis.connect(a,c,d,e),Apis));exports.reset=reset;const instance=(a="ws://localhost:8090",b,c=4e3,d,e)=>(Apis||(Apis=newApis(),Apis.setRpcConnectionStatusCallback(statusCb)),Apis&&b&&Apis.connect(a,c,d),e&&(Apis.closeCb=e),Apis);exports.instance=instance;const chainId=()=>instance().chain_id;exports.chainId=chainId;const close=async()=>{Apis&&(await Apis.close(),Apis=null)};exports.close=close;const get=a=>new Proxy([],{get:(b,c)=>(...b)=>Apis[a].exec(c,[...b])}),db=get("_db");exports.db=db;const network=get("_net");exports.network=network;const history=get("_hist");exports.history=history;const crypto=get("_crypt");exports.crypto=crypto;const orders=get("_orders");exports.orders=orders;const newApis=()=>({connect:(a,b,c={enableCrypto:!1,enableOrders:!1})=>{Apis.url=a;if("undefined"!=typeof window&&window.location&&"https:"===window.location.protocol&&0>a.indexOf("wss://"))throw new Error("Secure domains require wss connection");Apis.ws_rpc&&(Apis.ws_rpc.statusCb=null,Apis.ws_rpc.keepAliveCb=null,Apis.ws_rpc.on_close=null,Apis.ws_rpc.on_reconnect=null),Apis.ws_rpc=new _ChainWebSocket.default(a,Apis.statusCb,b,autoReconnect,a=>{Apis._db&&!a&&Apis._db.exec("get_objects",[["2.1.0"]]).catch(()=>{})}),Apis.init_promise=Apis.ws_rpc.login("","").then(()=>{Apis._db=new _GrapheneApi.default(Apis.ws_rpc,"database"),Apis._net=new _GrapheneApi.default(Apis.ws_rpc,"network_broadcast"),Apis._hist=new _GrapheneApi.default(Apis.ws_rpc,"history"),c.enableOrders&&(Apis._orders=new _GrapheneApi.default(Apis.ws_rpc,"orders")),c.enableCrypto&&(Apis._crypt=new _GrapheneApi.default(Apis.ws_rpc,"crypto"));var a=Apis._db.init().then(()=>Apis._db.exec("get_chain_id",[]).then(a=>(Apis.chain_id=a,_ChainConfig.default.setChainId(a))));Apis.ws_rpc.on_reconnect=()=>{Apis.ws_rpc&&Apis.ws_rpc.login("","").then(()=>{Apis._db.init().then(()=>{Apis.statusCb&&Apis.statusCb("reconnect")}),Apis._net.init(),Apis._hist.init(),c.enableOrders&&Apis._orders.init(),c.enableCrypto&&Apis._crypt.init()})},Apis.ws_rpc.on_close=()=>{Apis.close().then(()=>{Apis.closeCb&&Apis.closeCb()})};let b=[a,Apis._net.init(),Apis._hist.init()];return c.enableOrders&&b.push(Apis._orders.init()),c.enableCrypto&&b.push(Apis._crypt.init()),Promise.all(b)}).catch(b=>(console.error(a,"Failed to initialize with error",b&&b.message),Apis.close().then(()=>{throw b})))},close:async()=>{Apis.ws_rpc&&1===Apis.ws_rpc.ws.readyState&&(await Apis.ws_rpc.close()),Apis.ws_rpc=null},db_api:()=>Apis._db,network_api:()=>Apis._net,history_api:()=>Apis._hist,crypto_api:()=>Apis._crypt,orders_api:()=>Apis._orders,setRpcConnectionStatusCallback:a=>Apis.statusCb=a});