"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var Apis=_interopRequireWildcard(require("./ApiInstances")),_ChainWebSocket=_interopRequireDefault(require("./ChainWebSocket"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _getRequireWildcardCache(){if("function"!=typeof WeakMap)return null;var a=new WeakMap;return _getRequireWildcardCache=function(){return a},a}function _interopRequireWildcard(a){if(a&&a.__esModule)return a;if(null===a||"object"!=typeof a&&"function"!=typeof a)return{default:a};var b=_getRequireWildcardCache();if(b&&b.has(a))return b.get(a);var c={},d=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var e in a)if(Object.prototype.hasOwnProperty.call(a,e)){var f=d?Object.getOwnPropertyDescriptor(a,e):null;f&&(f.get||f.set)?Object.defineProperty(c,e,f):c[e]=a[e]}return c.default=a,b&&b.set(a,c),c}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}class Manager{constructor({url:b,urls:c,autoFallback:d,closeCb:e,optionalApis:f,urlChangeCallback:g}){_defineProperty(this,"setCloseCb",a=>{this.closeCb=a}),_defineProperty(this,"logFailure",(a,b,c)=>{let d=c&&c.message?c.message:"";console.error(a,"Failed to connect to "+b+(d?" Error: "+JSON.stringify(d):""))}),_defineProperty(this,"_onClose",()=>{this.isConnected=!1,this.closeCb&&(this.closeCb(),this.setCloseCb(null)),this.autoFallback&&this.connectWithFallback()}),_defineProperty(this,"connect",async(a=!0,b=this.url)=>{try{let c=await Apis.instance(b,a,void 0,this.optionalApis,this._onClose).init_promise;return this.url=b,this.isConnected=!0,c}catch(a){throw await Apis.close(),a}}),_defineProperty(this,"connectWithFallback",async(a=!0,b=this.url,c=0,d=null,e=null)=>{if(c>this.urls.length)return e(new Error("Tried "+c+" connections, none of which worked: "+JSON.stringify(this.urls.concat(this.url))));try{return await this.connect(a,b)}catch(b){return this.urlChangeCallback&&this.urlChangeCallback(this.urls[c]),this.connectWithFallback(a,this.urls[c],c+1,d,e)}}),_defineProperty(this,"checkConnections",async(a="",b="",c,d)=>{let e={},f=this.urls.concat(this.url),g=f.map(async c=>{/* Use default timeout and no reconnecting-websocket */let d=new _ChainWebSocket.default(c,()=>{},void 0,!1);e[c]=new Date().getTime();try{await d.login(a,b);let f={[c]:new Date().getTime()-e[c]};return await d.close(),f}catch(a){return c===this.url?this.url=this.urls[0]:this.urls=this.urls.filter(b=>b!==c),void(await d.close())}});try{let a=await Promise.all(g),b=a.filter(b=>!!b).sort((c,a)=>Object.values(c)[0]-Object.values(a)[0]).reduce((b,c)=>{let a=Object.keys(c)[0];return b[a]=c[a],b},{});return console.log(`Checked ${a.length} connections, ${a.length-Object.keys(b).length} failed`),b}catch(e){return this.checkConnections(a,b,c,d)}}),this.url=b,this.urls=c.filter(c=>c!==b),this.autoFallback=d,this.closeCb=e,this.optionalApis=f||{},this.isConnected=!1,this.urlChangeCallback=g}static close(){return Apis.close()}}var _default=Manager;exports.default=_default;